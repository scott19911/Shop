Реализовать HTML/CSS/jQuery шаблон для Internet-магазина.
Реализован шаблон главной страницы сайта
Реализована страницу регистрации пользователя и на ней сделана client-side validation введенной информации.
Использовать систему сборки Maven для сборки приложения.
Реализовать регистрацию пользователей сайта с защитой от роботов (капчей).

a. Реализовать валидацию данных пользователя на стороне клиента и на стороне сервера

i. На стороне сервера выполнить проверку на существование пользователя с введенным логином.

ii. Список существующих пользователей задать константами.

b. Сделать так, чтобы при ошибке клиенту не надо было заново вводить всю регистрационную информацию.

i. В качестве регистрационной информации надо использовать как минимум: имя, фамилия пользователя, пароль, адрес электронной почты, желаемые рассылки.

c. В качестве капчи использовать картинку с напечатанными на ней цифрами.

i. В качестве источника цифр можно использовать генератор псевдослучайных чисел с заданным начальным значением (seed)

ii. Можно добавить точек для усложнения автоматического распознавания, но это не обязательно

iii. Картинка должна генерироваться сервлетом. Для рисования капчи можно использовать сторонние библиотеки.

d. Продумать механизм хранения придуманного числа между этапами генерации картинки и проверки введенного значения.

i. Рекомендую нарисовать sequence diagram, отражающую взаимодействие клиента и сервера и пути передачи данных.

ii. Учитывать, что само придуманное число не должно посылаться клиенту в явном виде нигде, кроме как на изображении.

iii. Шифрование использовать нельзя

iv. Можно использовать коды загаданного числа.

e. Реализовать два варианта хранения данных (загаданного числа) – в атрибутах сессии и в контексте приложения.

i. Для второго варианта реализовать хранение идентификатора придуманного числа на стороне клиента при помощи cookie и скрытых полей формы.

f. Реализовать настройку выбора режима хранения данных капчи через параметры инициализации веб-приложения.

i. Подумать над тем, как сделать интерфейс модуля капчи независимым от механизма хранения придуманного числа.

g. Реализовать custom-tag для размещения картинки капчи и сопутствующих полей в JSP-странице.

i. Тег должен размещать HTML-код для отображения картинки

ii. При хранении идентификатора числа в скрытом поле формы – тег должен размещать это поле.

h. Протестировать систему в разных режимах. Составить модульные тесты для сервлета регистрации. Доказать и показать, что он удовлетворяет заданию.

i. Исправить ошибки. Если ошибок нет – исправить тесты.

2. Реализовать классы работы с пользователями.

a. Сделать класс репозитория и сервиса(-ов).

b. Подумать, где разумно будет разместить эти классы и какой минимально достаточный набор методов они должны содержать.

3. Реализовать тайм-аут для выполнения регистрации

a. Регистрация не должна выполняться, если с момента генерации страницы до момента получения данных формы от пользователя прошло больше заданного интервала времени.

i. Интервал задавать в настройках капчи

b. Устаревшие данные капчи должны удаляться из памяти. Возможны два варианта

i. Удаление происходит при запросе капчи / обработке регистрационных данных

ii. Удаление происходит в дополнительном Thread через определенный промежуток времени

c. Обосновать выбор и реализовать выбранный вариант

Задание 12.

1. Реализовать слой доступа к данным и сервисов с использованием MySQL и JDBC.

a. Написать соответствующие классы для управления соединением и транзакциями.

b. Написать классы DAO и сервисов для работы с пользователями.

2. Реализовать вход пользователя на сайт

a. Реализовать форму входа пользователя

b. Реализовать custom tag, который будет размещаться на странице в блоке фиксированного размера и содержать

i. Форму входа пользователя на сайт, если он еще не вошел на сайт

ii. Имя пользователя и кнопку выхода, если пользователь вошел на сайт

3. Загрузка файлов на сервер

a. Добавить к странице регистрации поле для добавления аватарки.

b. Реализовать загрузку аватарки на сервер и ее хранение в специальном каталоге сервера.

c. При последующем входе пользователя, на странице входа должна показываться его аватарка.
Задание 13.

1. Реализовать отображение списка товаров в интернет-магазине.

2. Реализовать класс хранения товаров (repository layer).

a. Класс должен обеспечивать фильтрацию товаров по названию товара, категориям, производителям и диапазону цен – по всем параметрам, которые есть в интерфейсе пользователя

i. С одним товаром связана одна категория и один производитель.

b. Также он должен обеспечивать частичное постраничное извлечение списка с соответствующим режимом сортировки.

3. Страница, выполняющая показ списка товаров, должна реализовывать следующую функциональность

a. Для каждого товара должна показываться базовая информация о нем (название, цена, описание с основными характеристиками) и его изображение (если задано).

b. На странице должно показывать не больше определенного числа товаров.

i. Реализовать возможность выбора числа товаров на страницу пользователем.

c. Если товаров больше, чем на одну страницу, должно показываться меню для выбора отображаемой страницы (набор ссылок на страницы)

d. Реализовать меню фильтрации товаров по категориям, производителям, названию товара и цене.

i. На экране вывести панель фильтрации, где пользователь может ввести ограничения на свойства товара.

ii. Ограничения фильтрации накладываются совместно, т.е. надо найти товар произведенный фирмой «Ааа» с ценой от 2 до 10 денег.

e. Реализовать сортировку товаров по нескольким полям (цена, название). Сортировка должна выполняться по одному выбранному полю в обоих направлениях.

f. Если товаров, удовлетворяющих условию, не найдено, то вместо списка товаров должна выводиться надпись: «Товаров не найдено».

g. Предусмотреть кнопку или гиперссылку для добавления товара в корзину.
Задание 14.

1. Реализовать возможность выбирать товары в корзину и выполнять покупку товаров.

2. Написать класс, реализующий корзину товаров

a. Корзина может быть картой, где ключ – товар, значение – число единиц товара.

b. Класс должен содержать методы

i. добавления товара в корзину,

ii. удаления товара из корзины,

iii. чтения списка отобранных в корзину товаров,

iv. чтения числа товаров в корзине,

v. вычисления общей суммы покупки по корзине.

3. Написать класс, для хранения информации о заказанных товарах

a. Класс должен хранить информацию о товаре, количество единиц товара и стоимость единицы товара на момент покупки.

b. Класс должен быть неизменяемым.

4. Написать класс, описывающий заказ.

a. Объект заказа должен содержать

i. идентификатор заказа;

ii. статус заказа (принят, подтвержден, формируется, выслан, завершен, отменен)

iii. детализацию состояния (почему состояние стало таким, как оно есть, например: «заказ отменен по просьбе клиента»)

iv. дату и время заказа;

v. информацию о пользователе, который сделал заказ;

vi. список заказанных товаров (см. пункт 3).

5. Написать классы слоя репозиториев для хранения заказов

a. Класс должен содержать метод для добавления заказа.

6. Создать страницу работы с корзиной.

a. На странице должен отображаться список товаров в корзине

b. Для каждого товара должна быть реализована возможность изменения числа единиц товара в корзине

c. Должны быть реализованы функции удаления товара из корзины и очистки корзины

d. Должен быть реализован заказ товаров из корзины

i. Если пользователь не зашел на сайт, то перед выполнением заказа потребовать регистрацию пользователя.

ii. В процессе заказа узнать у пользователя, какой тип оплаты/доставки он предпочитает

iii. Узнать платежные реквизиты пользователя

iv. После успешно выполненного заказа корзина должна быть очищена

Задание 15.

1. Реализовать фильтр, обеспечивающий локализацию веб приложения.

a. Фильтр должен определять текущую локаль приложения следующим образом:

i. Если выбранная локаль указана в хранилище (сессии или куке), то использовать ее

ii. Если в хранилище нет выбранной локали, то просмотреть список локалей, которые готов принять браузер.

Для этого можно воспользоваться методом getLocales() класса HttpServletRequest. Он возвращает локали в порядке уменьшения приемлемости локали для клиента.

Найти наиболее приемлемую локаль из тех, которые поддерживает приложение, и установить ее значение в сессию.

iii. Если никакая из переданных браузером локалей не поддерживается приложением, установить в качестве выбранной локали значение по умолчанию.

P.S.: В браузере можно настроить желаемую локализацию. В FireFox – пункт меню Tools->Options-> вкладка Content->Languages.

b. Список поддерживаемых приложением локалей и локаль по умолчанию задаются как параметры фильтра в дескрипторе развертывания.

P.S.: Подумать, что надо сделать, если деплойер задал неправильные параметры локализации. Т.е. как это проверить и что сделать.

c. Фильтр должен подменять локали запроса (getLocales() и getLocale()) на выбранную.

d. В веб-приложении как выбранную локаль надо использовать значение, возвращаемое методом HttpServletRequest.getLocale()

2. Написать набор тестов для проверки корректности работы фильтров локализации.

a. В тестах постараться учесть как можно больше вариантов

3. Написать custom tag для переключения языка в веб-приложении

a. Тег должен показывать названия языков или их пиктограммы

b. Тег должен использоваться во всех страницах приложения

c. Выбор языка осуществляется добавлением к адресу текущей страницы параметра lang=NM, где NM – название языка

d. Обработка параметра должна выполняться в фильтре из первого задания.

4. Реализовать хранение информации о локализации в куках и сессии.

a. Выбор варианта хранения должен задаваться в параметрах инициализации фильтра локализации.

b. Срок хранения кука должен отсчитываться от последнего посещения страницы сайта.

c. Срок хранения кука должен задаваться в параметрах приложения

5. Реализовать фильтр, выполняющий сжатие тела ответа для текстовых страниц.

a. Фильтр должен выполнять сжатие только если

i. установленный у ответа тип содержимого (Content-type) тесктовый;

ii. клиент может выполнить распаковку (установлено Accept-encoding: gzip);

b. Факт передачи сжатого ответа должен быть указан в заголовках ответа.

c. Подумать, как лучше выполнить отображение фильтра на ресурсы приложения – через web.xml или аннотации

6. Реализовать фильтр, выключающий кэширование
Задание 16.

1. Реализовать программное ограничение доступа к частям проекта.

2. Дописать классы сервисов управления пользователями.

a. Добавить нужное в UserService. Скорее всего нужно будет добавить проверку на существование логина пользователя и выполнение входа пользователя.

b. Желательно (но не обязательно, если не успеваете) в классе пользователя хранить информацию о числе неудачных попыток аутентификации и о времени/дате снятия блокировки с учетной записи пользователя, если он заблокирован.

i. В этом случае надо будет сделать автоматическую блокировку пользователя (бан) если он попытался сделать более определенного числа неудачных попыток входа.

3. Реализовать фильтр, ограничивающий доступ к URL-адресам сайта в соответствии с заданными ограничениями

a. Ограничения должны задаваться в xml-файле, путь к которому будет указываться в параметрах инициализации сервлета.

b. Формат xml-файла должен быть примерно таким:

<security>

<constraint>

<url-pattern> /admin/.* </url-pattern>

<role>admin</role >

</constraint>

<constraint>

<url-pattern> /user.*.do </url-pattern>

<role>admin</role >

</constraint>

<constraint>

<url-pattern> /internal/.* </url-pattern>

<role>user</role >

<role>admin</role >

</constraint>

</security>

В теге url-pattern можно указать либо полные названия путей к ресурсам с ограниченным доступом, либо (как в примере) регулярные выражения.

Рекомендую проверку того, разрешен ли доступ к ресурсу пользователю с определенной ролью, вынести в отдельный класс и отладить его работу вне веб-приложения.

c. Файл должен считываться при старте приложения. После этого настройки разделения доступа не должны изменяться.

d. Фильтр должен перехватывать все приходящие от клиента запросы (кроме статики). Для каждого запроса фильтр должен выполнять следующие проверки:

i. Есть ли запрашиваемая страница в списке страниц ограниченного доступа?

ii. НЕТ – передаем запрос дальше (chain.doFilter)

iii. ДА – Вошел ли пользователь в систему?

1. НЕТ – переадресовать пользователя на страницу входа

2. ДА – Дает ли роль пользователя доступ к запрашиваемой странице?

a. НЕТ – переадресовать пользователя на страницы ошибки доступа (sendRedirect)

b. ДА – передать запрос дальше (chain.doFilter)

e. Продумать, как можно вернуться к запрашиваемой странице после отображения страницы входа (заголовок HTTP Referer или URL параметр)

4. Реализовать страницы входа пользователя, выхода пользователя, ошибки доступа.
